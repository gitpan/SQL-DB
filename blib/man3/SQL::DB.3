.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::DB 3"
.TH SQL::DB 3 "2012-06-15" "perl v5.12.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::DB \- SQL database interface for Perl
.SH "VERSION"
.IX Header "VERSION"
0.191.0. Development release.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use SQL::DB \*(Aq:all\*(Aq;
\&    my $db = SQL::DB\->connect( \*(Aqdbi:...\*(Aq, \*(Aqusername\*(Aq, \*(Aqpassword\*(Aq );
\&
\&
\&    # The very simple stuff
\&
\&    my $success = $db\->insert(
\&        into   => \*(Aqactors\*(Aq,
\&        values => { id => 1, name => \*(AqJohn Smith\*(Aq },
\&    );
\&
\&    my $count = $db\->update(
\&        \*(Aqactors\*(Aq,
\&        set   => { name => \*(AqJack Smith\*(Aq },
\&        where => { id   => 1, name => \*(AqJohn Smith\*(Aq },
\&    );
\&
\&    my $count = $db\->delete(
\&        from  => \*(Aqactors\*(Aq,
\&        where => { actor_id => 1, last_name => \*(AqJones\*(Aq },
\&    );
\&
\&    my $row = $db\->select(
\&        [ \*(Aqid\*(Aq, \*(Aqname\*(Aq ],
\&        from  => \*(Aqactors\*(Aq,
\&        where => { id => 1 },
\&    );
\&
\&    print $row\->id . \*(Aq:\*(Aq . $row\->name . "\en";
\&
\&
\&    # The do\-any\-SQL\-you\-want stuff
\&
\&    my $people = $db\->irow(\*(Aqpeople\*(Aq);
\&
\&    $db\->do(
\&        insert_into => $people\->( \*(Aqid\*(Aq, \*(Aqname\*(Aq );
\&          sql_values( 1, \*(AqA Name\*(Aq ),
\&    );
\&
\&    # Anyone celebrating a birthday today gets a raise, with the
\&    # calculation done inside the database.
\&
\&    my $people = $db\->urow(\*(Aqpeople\*(Aq);
\&
\&    $db\->do(
\&        update => $people,
\&        set    => $people\->salary( $people\->salary * 2 ),
\&        where  => $people\->dob == $today,
\&    );
\&
\&    my $purchases = $db\->srow(\*(Aqpurchases\*(Aq);
\&
\&    my $row = $db\->fetch1(
\&        select    => [ $people\->name, $ps\->pid ],
\&        from      => $people,
\&        left_join => $purchases,
\&        on        => $purchases\->id == $people\->id,
\&        where => $people\->id\->in( 1, 2, 3 ) 
\&          . AND
\&          . $people\->name\->like(\*(Aq%paul%\*(Aq),
\&        limit  => 1,
\&        offset => 1,
\&    );
\&
\&    # then do stuff with $row\->pid, $row\->name etc
\&
\&    my @rows = $db\->fetch(
\&        select => [ sql_coalesce( $p\->pid, $p\->cid )\->as(\*(Aqpcid\*(Aq) ],
\&        from   => $p,
\&        where  => $p\->cid\->is_not_null,
\&    );
\&
\&    # coalesce column is available as $row\->pcid
\&
\&    my $iter = $db\->iter( @query ... );
\&    while ( my $row = $iter\->next ) {
\&        print $row\->column(), $row\->some_other_column;
\&    }
\&
\&    # If you want the data your own way you can still use the query
\&    # syntax:
\&    my $sth = $db\->sth(@query);
\&    map { print join( \*(Aq,\*(Aq, @$_ ) . "\en" } $sth\->fetchall_arrayref;
\&
\&    # Transactions provided by DBIx::Connector
\&    $db\->txn(
\&        sub {
\&
\&            # multiple statements
\&        }
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1SQL::DB\s0\fR is an extension to the Perl Database Interface (\s-1DBI\s0).  It
is designed for complicated queries and efficient access to results.
With an \s-1API\s0 that lets you easily write almost-raw \s-1SQL\s0, \s-1SQL::DB\s0 gives
you unfettered access to the power and flexibility of your underlying
database. It aims to be a tool for programmers who want their databases
to work just as hard as their Perl scripts.
.PP
\&\s-1SQL::DB\s0 gives you access to aggregate expressions, joins, nested
selects, unions and database-side operator invocations. Transactional
support is provided via DBIx::Connector.  Security conscious coders
will be pleased to know that all user-supplied values are bound
properly using \s-1DBI\s0 \*(L"\fIbind_param()\fR\*(R".  Binding binary data is handled
transparently across different database types.
.PP
\&\s-1SQL::DB\s0 offers a couple of very simple Create, Retrieve, Update and
Delete (\s-1CRUD\s0) action methods.  These are designed to get you up and
running quickly when your query data is already inside a hash. The
methods are abstractions of the real \s-1API\s0, but should still read as much
as possible like \s-1SQL\s0.
.PP
Although rows can be retrieved from the database as simple objects,
\&\s-1SQL::DB\s0 does not attempt to be an Object-Relational-Mapper (\s-1ORM\s0). There
are no auto-inflating columns or automatic joins and the code size and
speed reflect the lack of complexity.
.PP
\&\s-1SQL::DB\s0 uses the light-weight Log::Any for logging.
.SH "QUERY FORMAT"
.IX Header "QUERY FORMAT"
An \s-1SQL::DB\s0 query is composed from a list of scalars, schema objects,
expressions, and arrays as follows.
.IP "Scalars" 4
.IX Item "Scalars"
Scalars are assumed to be \s-1SQL\s0 keywords and are accepted more or less
unchanged (uppercased with underscores converted to spaces).
.Sp
.Vb 4
\&    Perl                            SQL
\&    \-\-\-\-                            \-\-\-
\&    \*(Aqselect\*(Aq                        SELECT
\&    \*(Aqouter_join\*(Aq                    OUTER JOIN
.Ve
.IP "Schema Objects" 4
.IX Item "Schema Objects"
and \s-1DELETE\s0.  A urow object maps to a table in the database. It has a
method for each of the columns in the table which return
column-objects. These column-objects in turn have further methods which
map to various \s-1SQL\s0 statements. The table and column objects are used in
positions as appropriate for their types.
.Sp
.Vb 8
\&    Perl                            SQL
\&    \-\-\-\-                            \-\-\-
\&    $table                          table  (for UPDATE statements)
\&    $table                          table0 (for SELECT statements)
\&    $table\->col > 1                 table0.col > ?
\&    $table\->col\->is_not_null        table0.col IS NULL
\&    $table\->col\->asc                table0.col ASC
\&    $table\->col\->between(1,5)       table0.col BETWEEN(?,?)
.Ve
.IP "Expressions" 4
.IX Item "Expressions"
Expressions are built using schema objects (described below) that hold
extra information such as table/column names and types, your
application's input values, and their relationships.
.Sp
.Vb 3
\&    Perl                            SQL
\&    \-\-\-\-                            \-\-\-
\&    $table\->col == 1                table0.col = ?
\&
\&    ($table\->col == 1) .AND.
\&      ($table.col2 = ?
\&    $table\->col > 1                 table0.col > ?
\&
\&    $table\->col ==                  table.col =
\&      $table\->col2 \- $table\->col3     table.col2 \- table.col3
.Ve
.IP "Arrays" 4
.IX Item "Arrays"
Arrays (array-refs) can contain scalars and expressions which will
appear in the final \s-1SQL\s0 joined together by commas (',').
.Sp
.Vb 4
\&    Perl                                    SQL
\&    \-\-\-\-                                    \-\-\-
\&    select => [1,2,3]                       SELECT ?,?,?
\&    set => [$t\->c1 == 1, $t\->c2 == 2 ]      SET t\->c1 = ?, t.c2 = ?
.Ve
.IP "Functions" 4
.IX Item "Functions"
Arrays (array-refs) can contain scalars and expressions which will
appear in the final \s-1SQL\s0 joined together by commas (',').
.Sp
.Vb 4
\&    Perl                                SQL
\&    \-\-\-\-                                \-\-\-
\&    sql_count($table\->col)              COUNT(table0.col)
\&    sql_values(\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq)           VALUES(?,?,?)
.Ve
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.ie n .IP "new( %args )" 4
.el .IP "new( \f(CW%args\fR )" 4
.IX Item "new( %args )"
Connect to a database and return a new \s-1SQL::DB\s0 handle. Arguments are as
follows:
.RS 4
.IP "dsn" 4
.IX Item "dsn"
The data source name ('dbi:...'). Required.
.IP "username" 4
.IX Item "username"
The database authentication username.
.IP "password" 4
.IX Item "password"
The database authentication password.
.IP "attr" 4
.IX Item "attr"
A hash-reference of \s-1DBI\s0 handle attributes.  RaiseError and
AutoCommit are always set to 1 and cannot be overridden.  PrintError
defaults to 0.  ChopBlanks defaults to 1. pg_enable_utf8,
sqlite_unicode, and mysql_enable_utf8 default to 1.
.IP "cache_sth" 4
.IX Item "cache_sth"
Whether to use the \s-1DBI\s0 \fIprepare_cached()\fR method. See \s-1ATTRIBUTES\s0
below.
.IP "schema" 4
.IX Item "schema"
The name of the schema class (less the '::Driver' part) associated with
this handle. See the command-line tool sqldb-schema(1) for details.
.RE
.RS 4
.RE
.ie n .IP "connect( $dsn, [ $username, $password, $attr ] )" 4
.el .IP "connect( \f(CW$dsn\fR, [ \f(CW$username\fR, \f(CW$password\fR, \f(CW$attr\fR ] )" 4
.IX Item "connect( $dsn, [ $username, $password, $attr ] )"
This is a convenience wrapper around \fInew()\fR for those who prefer
\&\s-1DBI\s0\-style construction.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.IP "conn \-> DBIx::Connector" 4
.IX Item "conn -> DBIx::Connector"
The handle connecting us to the database. Read-only.
.IP "dbd \-> Str" 4
.IX Item "dbd -> Str"
The database driver name (Pg, SQLite, etc). Read-only.
.IP "schema \-> SQL::DB::Schema" 4
.IX Item "schema -> SQL::DB::Schema"
The schema definition associated with this connection. Read-only.
.IP "cache_sth <\-> Bool" 4
.IX Item "cache_sth <-> Bool"
If true then the \s-1DBI\s0 \fIprepare_cached()\fR method will be used for
creating statement handles. Otherwise \fIprepare()\fR will be used.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "irow( @tables ) \-> @coderef" 4
.el .IP "irow( \f(CW@tables\fR ) \-> \f(CW@coderef\fR" 4
.IX Item "irow( @tables ) -> @coderef"
Returns coderefs for generating table/column strings.  In scalar
context returns a single coderef. Calling the coderef with column name
arguments returns a string of the form 'table(col1,col2)'.
.Sp
These refs can be used with the \fIdo()\fR method for \s-1INSERT\s0 queries.
.ie n .IP "urow( @tables ) \-> @URow" 4
.el .IP "urow( \f(CW@tables\fR ) \-> \f(CW@URow\fR" 4
.IX Item "urow( @tables ) -> @URow"
Returns schema objects representing database tables/rows for
update-style \s-1SQL\s0. In scalar context returns a single object.
.Sp
These objects have a method for each table column.  Each column object
has the following methods: \fIis_null()\fR, \fIis_not_null()\fR, \fIin()\fR, \fInot_in()\fR,
\&\fIbetween()\fR, \fInot_between()\fR, \fIas()\fR, \fIlike()\fR, \fIasc()\fR, and \fIdesc()\fR (see
SQL::DB::Expr for details).
.Sp
These objects can be used with the \fIdo()\fR method for \s-1UPDATE\s0 and \s-1DELETE\s0
queries.
.ie n .IP "srow( @tables ) \-> @SRow" 4
.el .IP "srow( \f(CW@tables\fR ) \-> \f(CW@SRow\fR" 4
.IX Item "srow( @tables ) -> @SRow"
Returns schema objects representing database tables/rows for
select-style \s-1SQL\s0. In scalar context returns a single object.
.Sp
These objects have a method for each table column.  Each column object
has the following methods: \fIis_null()\fR, \fIis_not_null()\fR, \fIin()\fR, \fInot_in()\fR,
\&\fIbetween()\fR, \fInot_between()\fR, \fIas()\fR, \fIlike()\fR, \fIasc()\fR, and \fIdesc()\fR (see
SQL::DB::Expr for details).
.Sp
These objects can be used with the \fIdo()\fR, \fIsth()\fR, \fIfetch()\fR, \fIfetch1()\fR, and
\&\fIiter()\fR methods for \s-1SELECT\s0 queries.
.ie n .IP "prepare( @query ) \-> ($sth, $query)" 4
.el .IP "prepare( \f(CW@query\fR ) \-> ($sth, \f(CW$query\fR)" 4
.IX Item "prepare( @query ) -> ($sth, $query)"
Prepares \f(CW@query\fR using \s-1DBI\s0 \fIprepare()\fR and returns a DBI::st
statement handle and the SQL::DB::Expr object representing the
query. Croaks on error.
.Sp
You need to call \fIexecute()\fR on the statement handle yourself afterwards.
.ie n .IP "prepare_cached( @query ) \-> ($sth, $query)" 4
.el .IP "prepare_cached( \f(CW@query\fR ) \-> ($sth, \f(CW$query\fR)" 4
.IX Item "prepare_cached( @query ) -> ($sth, $query)"
Prepares \f(CW@query\fR using \s-1DBI\s0 \fIprepare_cached()\fR and returns a DBI::st
statement handle and the SQL::DB::Expr object representing the
query. Croaks on error.
.Sp
You need to call \fIexecute()\fR on the statement handle yourself afterwards.
.ie n .IP "do(@query) \-> $count" 4
.el .IP "do(@query) \-> \f(CW$count\fR" 4
.IX Item "do(@query) -> $count"
Prepares (a \s-1INSERT\s0, \s-1UPDATE\s0 or \s-1DELETE\s0) \f(CW@query\fR using either \fIprepare()\fR or
\&\fIprepare_cached()\fR (depending on the \*(L"cache_sth\*(R" attribute) and
\&\fIexecute()\fR's the associated DBI::st statement handle. Croaks on
error.
.Sp
Returns the value of the \fIexecute()\fR call. The result is typically the
number of rows affected (but this is driver dependent).
.ie n .IP "sth( @query ) \-> DBI::st" 4
.el .IP "sth( \f(CW@query\fR ) \-> DBI::st" 4
.IX Item "sth( @query ) -> DBI::st"
Prepares (a \s-1SELECT\s0) \f(CW@query\fR using either \fIprepare()\fR or \fIprepare_cached()\fR
(depending on the \*(L"cache_sth\*(R" attribute) then \fIexecute()\fRs and returns
the associated DBI::st statement handle. Croaks on error.
.Sp
This method is useful if you want to obtain the data with one of the
\&\s-1DBI\s0 \fIfetchrow_hashref()\fR, \fIfetchall_arrayref()\fR etc methods.
.ie n .IP "object(@query) \-> $object" 4
.el .IP "object(@query) \-> \f(CW$object\fR" 4
.IX Item "object(@query) -> $object"
Prepares (a \s-1SELECT\s0) \f(CW@query\fR using either \fIprepare()\fR or \fIprepare_cached()\fR
(depending on the \*(L"cache_sth\*(R" attribute) and \fIexecute()\fR's it. Croaks on
error.
.Sp
Returns a single array-based object and closes the underlying statement
handle.  The object has accessor methods for each column selected.
.ie n .IP "objects(@query) \-> @objects" 4
.el .IP "objects(@query) \-> \f(CW@objects\fR" 4
.IX Item "objects(@query) -> @objects"
Prepares (a \s-1SELECT\s0) \f(CW@query\fR using either \fIprepare()\fR or \fIprepare_cached()\fR
(depending on the \*(L"cache_sth\*(R" attribute) and \fIexecute()\fR's it. Croaks on
error.
.Sp
Returns a list of array-based objects and closes the underlying
statement handle. Each object has accessor methods for each column
selected.
.Sp
Be aware that calling this method can consume large amounts of memory
if there are lots of rows to be retrieved. Consider using \fIiter()\fR
instead.
.IP "fetch1" 4
.IX Item "fetch1"
An alias for \fIobject()\fR.
.IP "fetch" 4
.IX Item "fetch"
An alias for \fIobjects()\fR.
.IP "hash" 4
.IX Item "hash"
Same as for \fIobject()\fR but returns a hashref instead.
.IP "hashes" 4
.IX Item "hashes"
Same as for \fIobjects()\fR but returns hashrefs instead.
.IP "array" 4
.IX Item "array"
Same as for \fIobject()\fR but returns an arrayref instead.
.IP "arrays" 4
.IX Item "arrays"
Same as for \fIobjects()\fR but returns arrayrefs instead.
.ie n .IP "iter( @query ) \-> SQL::DB::Iter" 4
.el .IP "iter( \f(CW@query\fR ) \-> SQL::DB::Iter" 4
.IX Item "iter( @query ) -> SQL::DB::Iter"
Prepares (a \s-1SELECT\s0) \f(CW@query\fR using either \fIprepare()\fR or \fIprepare_cached()\fR
(depending on the \*(L"cache_sth\*(R" attribute) and \fIexecute()\fR's it. Croaks on
error.
.Sp
Returns a cursor/iteration object with \fInext()\fR and \fIall()\fR methods for
retrieving array-based objects. Each object has accessor methods for
each column selected.
.IP "txn(&coderef)" 4
.IX Item "txn(&coderef)"
Runs the Perl code in &coderef as an \s-1SQL\s0 transaction. If &coderef does
not raise any exceptions then the transaction is commited, otherwise it
is rolled back. See DBIx::Connector for details.
.IP "current_timestamp \-> Str" 4
.IX Item "current_timestamp -> Str"
Returns the current \s-1UTC\s0 timestamp as a string in the form 'yyyy\-mm\-dd
hh:mm:ssZ'. The same value is always returned during a transaction.
.ie n .IP "query_as_string($sql, @bind_values) \-> Str" 4
.el .IP "query_as_string($sql, \f(CW@bind_values\fR) \-> Str" 4
.IX Item "query_as_string($sql, @bind_values) -> Str"
Pretty print an \s-1SQL\s0 query by inserting the bind values into the \s-1SQL\s0
itself.
.ie n .IP "insert(into => $table, values => \e%val) \-> Int" 4
.el .IP "insert(into => \f(CW$table\fR, values => \e%val) \-> Int" 4
.IX Item "insert(into => $table, values => %val) -> Int"
Insert a row into the database and return the number of rows affected.
.IP "update($table, set => \e%values, where => \e%expr) \-> Int" 4
.IX Item "update($table, set => %values, where => %expr) -> Int"
Update rows in the database and return the number of rows affected.
.Sp
This method is retricted to the wholesale replacement of column values
(no database-side calculations etc).  Multiple \s-1WHERE\s0 key/values are
only '\s-1AND\s0'd together. An 'undef' value maps to \s-1SQL\s0's \s-1NULL\s0 value.
.ie n .IP "delete(from => $table, where => \e%expr) \-> Int" 4
.el .IP "delete(from => \f(CW$table\fR, where => \e%expr) \-> Int" 4
.IX Item "delete(from => $table, where => %expr) -> Int"
Delete rows from the database and return the number of rows affected.
.ie n .IP "select(\e@columns, from => $table, where => \e%expr) \-> @Obj" 4
.el .IP "select(\e@columns, from => \f(CW$table\fR, where => \e%expr) \-> \f(CW@Obj\fR" 4
.IX Item "select(@columns, from => $table, where => %expr) -> @Obj"
Retrieve rows from the database as a list of objects in array context,
or a single object in scalar context. These objects (blessed into a
dynamically created class) have an accessor method for each column.
.Sp
The first argument to the \fIselect()\fR method must be either an array
reference of column names, or a single '*'. If the array reference is
given only the columns specified will be retrieved from the database.
.SH "CLASS FUNCTIONS"
.IX Header "CLASS FUNCTIONS"
The following functions can be exported individually or all at once
using the ':all' tag.  They all return an object which can be combined
with or used inside other functions.
.ie n .IP "bv( $value, [ $bind_type ] ) \-> SQL::DB::BindValue" 4
.el .IP "bv( \f(CW$value\fR, [ \f(CW$bind_type\fR ] ) \-> SQL::DB::BindValue" 4
.IX Item "bv( $value, [ $bind_type ] ) -> SQL::DB::BindValue"
This function returns an object which tells \s-1SQL::DB\s0 to bind \f(CW$value\fR
using a placeholder. The optional \f(CW$bind_type\fR is a database type
(integer, varchar, timestamp, bytea, etc) which will be converted to
the appropriate bind constant during a \fIprepare()\fR or \fIprepare_cached()\fR
call.
.ie n .IP "query( @query ) \-> SQL::DB::Expr" 4
.el .IP "query( \f(CW@query\fR ) \-> SQL::DB::Expr" 4
.IX Item "query( @query ) -> SQL::DB::Expr"
Build an \s-1SQL\s0 query using a list of scalars, schema objects,
expressions, other functions, and arrays. This function is the basis
for the \fIprepare()\fR, \fIprepare_cached()\fR, \fIdo()\fR, \fIsth()\fR, \fIiter()\fR, \fIfetch()\fR and
\&\fIfetch1()\fR methods.
.ie n .IP "sql_and( @args ) \-> SQL::DB::Expr" 4
.el .IP "sql_and( \f(CW@args\fR ) \-> SQL::DB::Expr" 4
.IX Item "sql_and( @args ) -> SQL::DB::Expr"
Maps to \*(L"$arg1 \s-1AND\s0 \f(CW$arg2\fR \s-1AND\s0 ...\*(R".
.ie n .IP "sql_case( @stmts ) \-> SQL::DB::Expr" 4
.el .IP "sql_case( \f(CW@stmts\fR ) \-> SQL::DB::Expr" 4
.IX Item "sql_case( @stmts ) -> SQL::DB::Expr"
Wraps \f(CW@stmts\fR inside a \s-1CASE/END\s0 pair while converting arguments to
expressions where needed.
.Sp
.Vb 5
\&    sql_case(
\&        when => $actors\->name\->is_null,
\&        then => \*(AqNo Name\*(Aq,
\&        else => $actors\->name,
\&    )\->as(\*(Aqname\*(Aq)
\&
\&    # CASE WHEN actors0.name IS NULL
\&    # THEN ? ELSE actors0.name END AS name
.Ve
.IP "sql_coalesce(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_coalesce(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1COALESCE\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.ie n .IP "sql_cast($arg1, as => $arg2) \-> SQL::DB::Expr" 4
.el .IP "sql_cast($arg1, as => \f(CW$arg2\fR) \-> SQL::DB::Expr" 4
.IX Item "sql_cast($arg1, as => $arg2) -> SQL::DB::Expr"
Maps to \*(L"\s-1CAST\s0( \f(CW$arg1\fR \s-1AS\s0 \f(CW$arg2\fR )\*(R".
.IP "sql_concat(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_concat(@args) -> SQL::DB::Expr"
Maps to \*(L"$arg1 || \f(CW$arg2\fR || ...\*(R".
.IP "sql_count(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_count(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1COUNT\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.IP "sql_exists(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_exists(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1EXISTS\s0(@args)\*(R".
.ie n .IP "sql_func('myfunc', @args) \-> SQL::DB::Expr" 4
.el .IP "sql_func('myfunc', \f(CW@args\fR) \-> SQL::DB::Expr" 4
.IX Item "sql_func('myfunc', @args) -> SQL::DB::Expr"
Maps to \*(L"\s-1MYFUNC\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.IP "sql_hex(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_hex(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1HEX\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.IP "sql_length(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_length(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1LENGTH\s0(@args)\*(R".
.IP "sql_lower(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_lower(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1LOWER\s0(@args)\*(R".
.IP "sql_ltrim(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_ltrim(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1LTRIM\s0(@args)\*(R".
.IP "sql_max(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_max(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1MAX\s0(@args)\*(R".
.IP "sql_min(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_min(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1MIN\s0(@args)\*(R".
.IP "sql_rtrim(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_rtrim(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1RTRIM\s0(@args)\*(R".
.IP "sql_sum(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_sum(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1MIN\s0(@args)\*(R".
.IP "sql_or(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_or(@args) -> SQL::DB::Expr"
Maps to \*(L"$arg1 \s-1OR\s0 \f(CW$arg2\fR \s-1OR\s0 ...\*(R".
.IP "sql_replace(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_replace(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1REPLACE\s0($arg1,$arg2 [,$arg3])\*(R".
.IP "sql_substr(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_substr(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1SUBSTR\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.ie n .IP "sql_table($name, @columns) \-> SQL::DB::Expr" 4
.el .IP "sql_table($name, \f(CW@columns\fR) \-> SQL::DB::Expr" 4
.IX Item "sql_table($name, @columns) -> SQL::DB::Expr"
Maps to \*(L"name(col1,col2,...)\*(R".
.IP "sql_upper(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_upper(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1UPPER\s0(@args)\*(R".
.IP "sql_values(@args) \-> SQL::DB::Expr" 4
.IX Item "sql_values(@args) -> SQL::DB::Expr"
Maps to \*(L"\s-1VALUES\s0($arg1, \f(CW$arg2\fR, ...)\*(R".
.SH "COMPATABILITY"
.IX Header "COMPATABILITY"
All \s-1SQL::DB\s0 releases have so far been \s-1DEVELOPMENT\s0!
.PP
\&\s-1SQL::DB\s0 jumped from version 0.18 to 0.191.0 due to a complete rewrite
based on Moo. Lots of things were simplified, modules deleted,
dependencies removed, etc. The \s-1API\s0 changed enough to almost give this
distribution a new name, except I don't know of anyone using this apart
from myself. 0.191.0 will be the last release marked as development,
0.99 will be a release candidate, and 1.00 will be the first stable
release.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DBIx::Connector, Log::Any
.SH "SUPPORT"
.IX Header "SUPPORT"
\&\s-1SQL::DB\s0 is managed via Github:
.PP
.Vb 1
\&    http://github.com/mlawren/sql\-db/
.Ve
.PP
\&\s-1SQL::DB\s0 follows a semantic versioning scheme:
.PP
.Vb 1
\&    http://semver.org
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Lawrence <nomad@null.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2007\-2011 Mark Lawrence <nomad@null.net>
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 General Public License as published by the
Free Software Foundation; either version 3 of the License, or (at your
option) any later version.
