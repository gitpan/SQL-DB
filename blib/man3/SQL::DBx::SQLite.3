.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::DBx::SQLite 3"
.TH SQL::DBx::SQLite 3 "2012-06-21" "perl v5.12.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::DBx::SQLite \- add various features to to SQLite
.SH "VERSION"
.IX Header "VERSION"
0.191.0. Development release.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use SQL::DB;
\&    use SQL::DBx::SQLite;
\&
\&    my $db = SQL::DB\->connect($dsn);
\&
\&    $db\->sqlite_create_function_sha1;
\&    $db\->sqlite_create_function_debug;
\&
\&    $db\->conn\->dbh\->do( q{
\&        CREATE TRIGGER calculate_hash AFTER UPDATE ON table
\&        FOR EACH ROW
\&        BEGIN
\&            UPDATE
\&                table
\&            SET
\&                sha1 = sha1_hex(source)
\&            WHERE
\&                id = NEW.id
\&
\&            SELECT debug(\*(Aqselect * from table\*(Aq);
\&        END;
\&    });
\&
\&    $db\->sqlite_create_sequence(\*(Aqtable\*(Aq);
\&    my $next_id = $db\->nextval(\*(Aqtable\*(Aq);
\&
\&    # Alternatively:
\&
\&    $db\->sqlite_create_function_nextval;
\&    $db\->conn\->dbh\->do(q{
\&        INSERT INTO table VALUES(nextval(\*(Aqtable\*(Aq), \*(Aqstuff\*(Aq);
\&    });
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBSQL::DBx::SQLite\fR adds various functions to the \s-1SQL\s0 syntax understood
by SQLite, using the \fI\fIsqlite_create_function()\fI\fR and
\&\fI\fIsqlite_create_aggregate_function()\fI\fR methods of DBD::SQLite. It
also adds a kind of sequence \s-1API\s0 to \s-1SQL::DB\s0 for SQLite databases.
.PP
All user-defined SQLite functions are only valid for the current
session.  They must be created each time you connect to the database.
If you want that to happen automatically you might try something like
the following in your class:
.PP
.Vb 4
\&    after BUILD => sub {
\&        my $self = shift;
\&        $self\->sqlite_create_debug_function;
\&    };
.Ve
.SH "METHODS"
.IX Header "METHODS"
.IP "sqlite_create_function_debug" 4
.IX Item "sqlite_create_function_debug"
Add a \fIdebug()\fR function to the \s-1SQL\s0 understood by SQLite;
.IP "sqlite_create_function_sha1" 4
.IX Item "sqlite_create_function_sha1"
Add various \s-1SHA\s0 digest functions to the \s-1SQL\s0 understood by SQLite, The
following have the same syntax in \s-1SQL\s0 as described in
Digest::SQLite:
.RS 4
.IP "sha1" 4
.IX Item "sha1"
Calculate the SQLite digest of all arguments concatenated together and
return it in a 20\-byte binary form. Unfortunately it seems that the
underlying SQLite C \fIsqlite_create_function()\fR provides no way to
identify the result as a blob, so you must always manually cast the
result in \s-1SQL\s0 like so:
.Sp
.Vb 1
\&    CAST(sha1(SQLITE_EXPRESSION) AS blob)
.Ve
.IP "sha1_hex" 4
.IX Item "sha1_hex"
Calculate the SQLite digest of all arguments concatenated together and
return it in a 40\-character hexidecimal form.
.IP "sha1_base64" 4
.IX Item "sha1_base64"
Calculate the SQLite digest of all arguments concatenated together and
return it in a 27\-character base64 encoded form.
.RE
.RS 4
.Sp
Also created are \fIagg_sha1\fR, \fIagg_sha1_hex\fR and \fIagg_sha1_base64\fR
functions that serve the same purpose but as aggregate functions.
.RE
.IP "sqlite_create_function_nextval" 4
.IX Item "sqlite_create_function_nextval"
Add a \fInextval()\fR function to the \s-1SQL\s0 understood by SQLite. See also
\&\fIsql_nextval\fR from \s-1SQL::DB\s0.
.IP "sqlite_create_function_currval" 4
.IX Item "sqlite_create_function_currval"
Add a \fIcurrval()\fR function to the \s-1SQL\s0 understood by SQLite. See also
\&\fIsql_currval\fR from \s-1SQL::DB\s0.
.ie n .IP "sqlite_create_sequence( $name )" 4
.el .IP "sqlite_create_sequence( \f(CW$name\fR )" 4
.IX Item "sqlite_create_sequence( $name )"
Create a sequence in the database with name \f(CW$name\fR. An \*(L"\s-1INTEGER\s0 \s-1PRIMARY\s0
\&\s-1KEY\s0 \s-1AUTOINCREMENT\s0\*(R" column in SQLite will automatically create a
sequence named after the containing table.
.ie n .IP "nextval( $name ) \-> Int" 4
.el .IP "nextval( \f(CW$name\fR ) \-> Int" 4
.IX Item "nextval( $name ) -> Int"
Advance the sequence to its next value and return that value.
.ie n .IP "currval( $name ) \-> Int" 4
.el .IP "currval( \f(CW$name\fR ) \-> Int" 4
.IX Item "currval( $name ) -> Int"
Return the current value of the sequence.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Digest::SHA, \s-1SQL::DB\s0, Moo::Role
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Lawrence <nomad@null.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2012 Mark Lawrence <nomad@null.net>
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 General Public License as published by the
Free Software Foundation; either version 3 of the License, or (at your
option) any later version.
