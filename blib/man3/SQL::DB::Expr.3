.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::DB::Expr 3"
.TH SQL::DB::Expr 3 "2012-06-15" "perl v5.12.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::DB::Expr \- Build SQL expressions with Perl
.SH "VERSION"
.IX Header "VERSION"
0.191.0. Development release.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use SQL::DB::Expr;
\&
\&  my $col1 = SQL::DB::Expr\->new(
\&    _txt => \*(Aqcol1\*(Aq,
\&    _type => \*(Aqinteger\*(Aq,
\&  );
\&
\&  my $col2 = SQL::DB::Expr\->new(
\&    _txt => \*(Aqcol2\*(Aq,
\&  );
\&
\&  my $expr = ($col1\->is_not_null .AND.
\&    $col2\->between(1,2))\->as(\*(Aqalias\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBSQL::DB::Expr\fR provides an object class that supports mapping Perl
syntax to \s-1SQL\s0 text, values and types suitable for passing to \s-1DBI\s0
methods.  This class is the basis for \s-1SQL::DB\s0 and is not generally
used directly.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.Vb 5
\&    new(
\&        _txt     => $_txt,
\&        _type    => $column_type,
\&        _multi   => $_multi,
\&    );
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.IP "_txt => Scalar" 4
.IX Item "_txt => Scalar"
The \s-1SQL\s0 representation of the expression suitable for passing to \s-1DBI\s0
methods such as \fIdo()\fR, \fIselectall_arrayref()\fR, \fIprepare()\fR, etc.
.IP "_type => Scalar" 4
.IX Item "_type => Scalar"
The column type definition. \s-1SQL::DB\s0 converts this at query run time
to a type suitable for passing to a \s-1DBI\s0 \fI\fIbind_param()\fI\fR method call.
.IP "_multi => Bool" 4
.IX Item "_multi => Bool"
Whether the expression requires surrounding brackets.
.SH "METHODS"
.IX Header "METHODS"
.IP "\s-1BUILD\s0" 4
.IX Item "BUILD"
A subroutine called during an object's instantiation phase.
.IP "_clone" 4
.IX Item "_clone"
Makes a deep copy of the object.
.IP "_as_string" 4
.IX Item "_as_string"
Returns a string representation of the expression, providing
surrounding brackets for '_multi' expressions.
.IP "_as_pretty($dbh) \-> Str" 4
.IX Item "_as_pretty($dbh) -> Str"
Returns the expression as an \s-1SQL\s0 string with values interpolated.
.IP "_sql_values_types($dbh) \-> ($sql, \e@values, \e@types)" 4
.IX Item "_sql_values_types($dbh) -> ($sql, @values, @types)"
Returns an \s-1SQL\s0 string with placeholder values, an array of values and
an array of \s-1DBI\s0 bind types.
.IP "_expr_not" 4
.IX Item "_expr_not"
Maps '!' to '\s-1NOT\s0'.
.IP "_expr_eq" 4
.IX Item "_expr_eq"
Maps '==' and 'eq' to \*(L"=\*(R".
.IP "_expr_ne" 4
.IX Item "_expr_ne"
Maps '!=' and 'ne' to \*(L"!=\*(R".
.IP "_expr_bitand" 4
.IX Item "_expr_bitand"
Maps '&' to \*(L"&\*(R";
.IP "_expr_bitor" 4
.IX Item "_expr_bitor"
Maps '|' to \*(L"|\*(R";
.IP "_expr_lt" 4
.IX Item "_expr_lt"
Maps '<' to \*(L"<\*(R";
.IP "_expr_gt" 4
.IX Item "_expr_gt"
Maps '>' to \*(L">\*(R";
.IP "_expr_lte" 4
.IX Item "_expr_lte"
Maps '<=' to \*(L"<=\*(R";
.IP "_expr_gte" 4
.IX Item "_expr_gte"
Maps '>=' to \*(L">=\*(R";
.IP "_expr_add" 4
.IX Item "_expr_add"
Maps '+' to \*(L"+\*(R";
.IP "_expr_sub" 4
.IX Item "_expr_sub"
Maps '\-' to \*(L"\-\*(R";
.IP "_expr_mult" 4
.IX Item "_expr_mult"
Maps '*' to \*(L"*\*(R";
.IP "_expr_divide" 4
.IX Item "_expr_divide"
Maps '/' to \*(L"/\*(R";
.IP "is_null" 4
.IX Item "is_null"
Maps to \*(L"\s-1IS\s0 \s-1NULL\s0\*(R".
.IP "is_not_null" 4
.IX Item "is_not_null"
Maps to \*(L"\s-1IS\s0 \s-1NOT\s0 \s-1NULL\s0\*(R".
.IP "in(@values)" 4
.IX Item "in(@values)"
Maps to \*(L"\s-1IN\s0 (@VALUES)\*(R"
.ie n .IP "not_in( @values )" 4
.el .IP "not_in( \f(CW@values\fR )" 4
.IX Item "not_in( @values )"
Maps to \*(L"\s-1NOT\s0 \s-1IN\s0 ( \f(CW@VALUES\fR )\*(R".
.ie n .IP "between( $a, $b )" 4
.el .IP "between( \f(CW$a\fR, \f(CW$b\fR )" 4
.IX Item "between( $a, $b )"
Maps to \*(L"\s-1BETWEEN\s0 \f(CW$a\fR \s-1AND\s0 \f(CW$b\fR\*(R".
.ie n .IP "not_between( $a, $b )" 4
.el .IP "not_between( \f(CW$a\fR, \f(CW$b\fR )" 4
.IX Item "not_between( $a, $b )"
Maps to \*(L"\s-1NOT\s0 \s-1BETWEEN\s0 \f(CW$a\fR \s-1AND\s0 \f(CW$b\fR\*(R".
.ie n .IP "as( $as )" 4
.el .IP "as( \f(CW$as\fR )" 4
.IX Item "as( $as )"
Maps to \*(L"\s-1AS\s0 \f(CW$as\fR\*(R".
.ie n .IP "like( $like )" 4
.el .IP "like( \f(CW$like\fR )" 4
.IX Item "like( $like )"
Maps to \*(L"\s-1LIKE\s0 \f(CW$like\fR\*(R".
.IP "asc" 4
.IX Item "asc"
Maps to \*(L"\s-1ASC\s0\*(R".
.IP "desc" 4
.IX Item "desc"
Maps to \*(L"\s-1DESC\s0\*(R".
.SH "CLASS FUNCTIONS"
.IX Header "CLASS FUNCTIONS"
The following functions are exported on demand.
.ie n .IP "_quote( $value [,$bind_type] ) \-> SQL::DB::Quote" 4
.el .IP "_quote( \f(CW$value\fR [,$bind_type] ) \-> SQL::DB::Quote" 4
.IX Item "_quote( $value [,$bind_type] ) -> SQL::DB::Quote"
Returns an object which is recognized by \s-1SQL::DB\s0 as something which
should be quoted before being prepared.
.ie n .IP "_bval( $value [,$bind_type] ) \-> SQL::DB::BindValue" 4
.el .IP "_bval( \f(CW$value\fR [,$bind_type] ) \-> SQL::DB::BindValue" 4
.IX Item "_bval( $value [,$bind_type] ) -> SQL::DB::BindValue"
Returns an object which is recognized by \s-1SQL::DB\s0 as something which
should be bound (via a placeholder) before being prepared.
.ie n .IP "_expr_binary( $op, $e1, $e2, $swap )" 4
.el .IP "_expr_binary( \f(CW$op\fR, \f(CW$e1\fR, \f(CW$e2\fR, \f(CW$swap\fR )" 4
.IX Item "_expr_binary( $op, $e1, $e2, $swap )"
A method for building binary operator expressions.
.ie n .IP "_expr_join( $separator, @expressions )" 4
.el .IP "_expr_join( \f(CW$separator\fR, \f(CW@expressions\fR )" 4
.IX Item "_expr_join( $separator, @expressions )"
Does the same as Perl's 'join' built-in. but for SQL::DB::Expr objects.
See \s-1BUGS\s0 below for why this is needed.
.IP "\s-1AND\s0, \s-1OR\s0" 4
.IX Item "AND, OR"
These subroutines let you write \s-1SQL\s0 logical expressions in Perl using
string concatenation:
.Sp
.Vb 1
\&    ( $e1 .AND. $e2 ) .OR. ( $e3 .AND. $e4 )
.Ve
.Sp
Note that due to operator precedence, expressions either side of .AND.
or .OR. should be bracketed if they are not already single expression
objects.
.Sp
Things are implemented this way due to Perl not allowing the
overloading of the 'and' and 'or' built-ins.
.SH "BUGS"
.IX Header "BUGS"
Using \fBSQL::DB::Expr\fR objects with the Perl \*(L"join\*(R" command does not
work as expected, apparently because join does not trigger either the
\&'.' or '.=' overload methods. The work around is to use the _expr_join
subroutine.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1SQL::DB\s0, \s-1DBI\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Lawrence <nomad@null.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2007\-2011 Mark Lawrence <nomad@null.net>
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 General Public License as published by the
Free Software Foundation; either version 3 of the License, or (at your
option) any later version.
