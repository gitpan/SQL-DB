.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::DB::Iter 3"
.TH SQL::DB::Iter 3 "2012-06-15" "perl v5.12.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::DB::Iter \- SQL::DB database iterator
.SH "VERSION"
.IX Header "VERSION"
0.191.0. Development release.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use SQL::DB::Iter;
\&
\&  my $iter = SQL::DB::Iter\->new(
\&      sth => $sth,
\&  );
\&
\&  while (my $row = $iter\->next) {
\&      print $row\->column(), $row\->some_other_column;
\&  }
\&
\&  # Or if you want you can get everything at once:
\&  my @rows = $iter\->all;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBSQL::DB::Iter\fR is a class for traversing over records retrieved from
a \s-1DBI\s0 statement handle. Note that this is a Perl-side iterator,
completely unrelated to any database-side cursors.
.PP
The objects returned by the 'next' and 'all' methods are simple
array-ref based objects with one accessor/modifer method per column.
Method names are column names with spaces replaced by a '_'.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.ie n .IP "new(sth => $sth)" 4
.el .IP "new(sth => \f(CW$sth\fR)" 4
.IX Item "new(sth => $sth)"
Returns a new iterator object. \f(CW$sth\fR must be a \s-1DBI\s0 statement handle
that has already been 'executed'.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.IP "sth \-> DBI::st" 4
.IX Item "sth -> DBI::st"
The \s-1DBI\s0 statement handle. Read-only.
.IP "class \-> Str" 4
.IX Item "class -> Str"
The class name into which retrieved rows are 'blessed'. This is
automatically calculated based on the retrieved column names.
Read-only.
.SH "METHODS"
.IX Header "METHODS"
.IP "\s-1BUILD\s0" 4
.IX Item "BUILD"
Internal method.
.ie n .IP "next \-> $row" 4
.el .IP "next \-> \f(CW$row\fR" 4
.IX Item "next -> $row"
Returns the next row from the statement handle as an object. Returns
undef when there is no more data.
.ie n .IP "all \-> @rows" 4
.el .IP "all \-> \f(CW@rows\fR" 4
.IX Item "all -> @rows"
Returns all remaining rows from the statement handle as a list of
objects. Returns the empty list if no data is available.
.ie n .IP "object \-> $obj" 4
.el .IP "object \-> \f(CW$obj\fR" 4
.IX Item "object -> $obj"
Returns the next row from the statement handle as an object. Returns
undef when there is no more data.
.ie n .IP "objects \-> @objects" 4
.el .IP "objects \-> \f(CW@objects\fR" 4
.IX Item "objects -> @objects"
Returns all remaining rows from the statement handle as a list of
objects. Returns the empty list if no data is available.
.ie n .IP "hash \-> $HashRef" 4
.el .IP "hash \-> \f(CW$HashRef\fR" 4
.IX Item "hash -> $HashRef"
Returns the next row from the statement handle as a reference to a
hash. Returns undef when there is no more data.
.ie n .IP "hashes \-> @HashRefs" 4
.el .IP "hashes \-> \f(CW@HashRefs\fR" 4
.IX Item "hashes -> @HashRefs"
Returns all remaining rows from the statement handle as a list of
references to hashes. Returns the empty list if no data is available.
.ie n .IP "array \-> $ArrayRef" 4
.el .IP "array \-> \f(CW$ArrayRef\fR" 4
.IX Item "array -> $ArrayRef"
Returns the next row from the statement handle as a reference to an
array. Returns undef when there is no more data.
.ie n .IP "arrays \-> @ArrayRefs" 4
.el .IP "arrays \-> \f(CW@ArrayRefs\fR" 4
.IX Item "arrays -> @ArrayRefs"
Returns all remaining rows from the statement handle as a list of
references to arrays. Returns the empty list if no data is available.
.IP "finish" 4
.IX Item "finish"
Calls \fIfinish()\fR on the \s-1DBI\s0 statement handle and internally records that
there is no more data to be retrieved. This method is automatically
called when the iterator object goes out of scope, so be aware you
cannot use the passed-in statement handle again.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0, \s-1SQL::DB\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Lawrence <nomad@null.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2007\-2011 Mark Lawrence <nomad@null.net>
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 General Public License as published by the
Free Software Foundation; either version 3 of the License, or (at your
option) any later version.
